# Comprehensive Protection Guide for HTTP/2 Load Testing Attacks

## Overview

This guide provides comprehensive protection strategies against HTTP/2 and HTTP/1.1 flood attacks generated by the TORNADO (http-storm.js) tool. The protection approach uses **multi-layer defense** with signature-based detection, rate limiting, and behavioral analysis.

---

## Table of Contents

- [Attack Signatures](#attack-signatures)
- [Detection Methods](#detection-methods)
- [Protection Layers](#protection-layers)
- [Rate Limiting Strategies](#rate-limiting-strategies)
- [WAF Rules](#waf-rules)
- [Application-Level Protection](#application-level-protection)
- [Monitoring & Alerting](#monitoring--alerting)
- [CDN Protection](#cdn-protection)
- [Advanced Detection](#advanced-detection)
- [Complete Protection Scripts](#complete-protection-scripts)

---

## Attack Signatures

### HTTP/2 Signatures

The tool generates specific HTTP/2 patterns that can be detected:

#### 1. HTTP/2 SETTINGS Frame Patterns

```javascript
// Specific SETTINGS values used by http-storm.js
SETTINGS_HEADER_TABLE_SIZE: 65535-65537 (randomized)
SETTINGS_ENABLE_PUSH: 0
SETTINGS_MAX_CONCURRENT_STREAMS: 131072-6291456 (specific values)
SETTINGS_INITIAL_WINDOW_SIZE: 262142-262146 (specific values)
```

**Detection Pattern:**
- Header table size exactly 65535, 65536, or 65537
- Max concurrent streams: 131072, 131073, 131074, 6291454, 6291455, or 6291456
- Initial window size: 262142, 262143, 262144, 262145, or 262146

#### 2. WINDOW_UPDATE Frame Pattern

```javascript
// Specific window update value
WINDOW_UPDATE_INCREMENT: 15663105
```

**Detection:** Window update frame with increment value of exactly 15663105.

#### 3. Stream ID Pattern

```javascript
// Sequential odd stream IDs
Stream IDs: 1, 3, 5, 7, 9, 11, 13, 15...
```

**Detection:** Stream IDs increment by 2 (odd numbers only).

#### 4. HPACK Header Patterns

```javascript
// Specific header encoding patterns
Headers always include:
- :method (GET/POST/HEAD/OPTIONS)
- :authority (target hostname)
- :scheme (https)
- :path (with query strings)
- sec-ch-ua (specific brand values)
- user-agent (Chrome 120-123)
```

**Detection:** Consistent header ordering and specific sec-ch-ua brand patterns.

#### 5. HTTP/2 Preface Pattern

```javascript
// HTTP/2 connection preface
PREFACE = "PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n"
```

**Detection:** Standard HTTP/2 preface (normal, but can be logged for analysis).

### HTTP/1.1 Signatures

#### 1. Header Patterns

```javascript
// Consistent header structure
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate, br
Accept-Language: en-US,en;q=0.7
Connection: Keep-Alive
Sec-Fetch-Dest: document
Sec-Fetch-Mode: navigate
Sec-Fetch-Site: none
Sec-Fetch-User: ?1
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/142.0.0.0 Safari/537.36
```

**Detection:** Exact header order and values matching the pattern.

#### 2. Query String Patterns

```javascript
// Cloudflare challenge token pattern (--query 1)
?__cf_chl_rt_tk=<30_chars>_<12_chars>-<timestamp>-0-gaNy<8_chars>

// Random query pattern (--query 2)
?<6-7_chars>&<6-7_chars>

// Standard query pattern (--query 3)
?q=<6-7_chars>&<6-7_chars>
```

**Detection:** Query string patterns matching these formats.

#### 3. Cookie Patterns (Bot Fight Mode)

```javascript
// Cloudflare bot fight mode cookies
__cf_bm=<23_chars>_<19_chars>-<timestamp>-1-<4_chars>/<65_chars>+<16_chars>=
cf_clearance=<35_chars>_<7_chars>-<timestamp>-0-1-<8_chars>.<8_chars>.<8_chars>-0.2.<timestamp>
```

**Detection:** Cookie patterns matching Cloudflare challenge format.

---

## Detection Methods

### 1. Rate-Based Detection

Monitor requests per second (RPS) per IP address:

```python
# Python detection script
import time
from collections import defaultdict

request_counts = defaultdict(list)
THRESHOLD_RPS = 50  # requests per second
WINDOW_SECONDS = 1

def detect_attack(ip_address):
    current_time = time.time()
    request_counts[ip_address].append(current_time)
    
    # Remove old entries
    request_counts[ip_address] = [
        t for t in request_counts[ip_address]
        if current_time - t < WINDOW_SECONDS
    ]
    
    # Check threshold
    if len(request_counts[ip_address]) > THRESHOLD_RPS:
        return True, len(request_counts[ip_address])
    
    return False, len(request_counts[ip_address])
```

### 2. HTTP/2 Settings Detection

Detect specific SETTINGS frame values:

```python
def detect_http2_settings(settings_frame):
    """Detect suspicious HTTP/2 SETTINGS values"""
    suspicious_values = {
        'HEADER_TABLE_SIZE': [65535, 65536, 65537],
        'MAX_CONCURRENT_STREAMS': [131072, 131073, 131074, 6291454, 6291455, 6291456],
        'INITIAL_WINDOW_SIZE': [262142, 262143, 262144, 262145, 262146]
    }
    
    for setting_id, value in settings_frame.items():
        if setting_id in suspicious_values:
            if value in suspicious_values[setting_id]:
                return True, f"Suspicious {setting_id}: {value}"
    
    return False, None
```

### 3. Stream ID Pattern Detection

Detect sequential odd stream IDs:

```python
def detect_stream_pattern(stream_ids):
    """Detect sequential odd stream IDs"""
    if len(stream_ids) < 5:
        return False
    
    # Check if all are odd and sequential
    for i in range(1, len(stream_ids)):
        if stream_ids[i] % 2 == 0:  # Even number
            return False
        if stream_ids[i] - stream_ids[i-1] != 2:  # Not sequential
            return False
    
    return True
```

### 4. Header Pattern Detection

Detect consistent header patterns:

```python
def detect_header_pattern(headers):
    """Detect consistent header patterns from http-storm.js"""
    suspicious_patterns = {
        'user-agent': r'Chrome/14[0-3]\.0\.0\.0',
        'sec-ch-ua': r'"Not[^"]*Brand"[^"]*"Chromium"[^"]*"Chrome"',
        'accept': r'text/html.*application/xhtml\+xml.*image/avif.*image/webp',
    }
    
    for header_name, pattern in suspicious_patterns.items():
        if header_name in headers:
            import re
            if re.match(pattern, headers[header_name], re.IGNORECASE):
                return True, f"Suspicious {header_name} pattern"
    
    return False, None
```

---

## Protection Layers

### Layer 1: CDN/DDoS Protection Service

#### Cloudflare Configuration

```javascript
// Cloudflare WAF Rules
// Rule 1: Rate limiting
(http.request.uri.path matches "^/api/") and 
(http.request.rate.ge(100)) 
-> Block

// Rule 2: HTTP/2 settings detection
(http.request.protocol eq "HTTP/2") and
(http.request.headers["x-custom-header"] exists) and
(not http.request.headers["x-forwarded-for"] exists)
-> Challenge

// Rule 3: Bot detection
(cf.bot_management.score lt 30) and
(http.request.rate.ge(50))
-> Challenge

// Rule 4: Known proxy IPs
(ip.src.ip in $known_proxy_ips)
-> Block
```

#### AWS Shield Advanced

```json
{
  "Name": "HTTP-Flood-Protection",
  "ResourceArn": "arn:aws:cloudfront::*:distribution/*",
  "Action": {
    "Block": {}
  },
  "Statement": {
    "RateBasedStatement": {
      "Limit": 2000,
      "AggregateKeyType": "IP"
    }
  },
  "VisibilityConfig": {
    "SampledRequestsEnabled": true,
    "CloudWatchMetricsEnabled": true,
    "MetricName": "HTTPFloodProtection"
  }
}
```

### Layer 2: Web Server Rate Limiting

#### Nginx Configuration

```nginx
# Define rate limit zones
http {
    # Per-IP rate limiting
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=20r/s;
    limit_req_zone $binary_remote_addr zone=general_limit:10m rate=50r/s;
    
    # Connection limiting
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;
    limit_conn conn_limit 10;
    
    # HTTP/2 detection
    map $http2 $http2_detected {
        default 0;
        "h2" 1;
    }
    
    server {
        listen 443 ssl http2;
        
        # API endpoints - stricter limits
        location /api/ {
            limit_req zone=api_limit burst=30 nodelay;
            limit_req_status 429;
            
            # Additional checks
            if ($http2_detected = 1) {
                # Log HTTP/2 requests for analysis
                access_log /var/log/nginx/http2_access.log;
            }
            
            # ... rest of config
        }
        
        # General pages
        location / {
            limit_req zone=general_limit burst=50 nodelay;
            limit_req_status 429;
            
            # ... rest of config
        }
        
        # Error page for rate limiting
        error_page 429 @ratelimit;
        location @ratelimit {
            return 429 '{"error": "Rate limit exceeded"}';
            add_header Content-Type application/json;
        }
    }
}
```

#### Apache Configuration (mod_evasive)

```apache
<IfModule mod_evasive20.c>
    DOSHashTableSize    3097
    DOSPageCount        10
    DOSSiteCount        50
    DOSPageInterval     1
    DOSSiteInterval     1
    DOSBlockingPeriod   600
    
    # Email notifications
    DOSEmailNotify      admin@example.com
    DOSLogDir           /var/log/mod_evasive
</IfModule>
```

### Layer 3: WAF (Web Application Firewall)

#### ModSecurity Rules

```apache
# ModSecurity rules for HTTP/2 flood detection

# Rule 1: Detect high request rate
SecRule REQUEST_COUNT "@gt 50" \
    "id:1001,\
    phase:1,\
    block,\
    msg:'High request rate detected',\
    logdata:'Request count: %{REQUEST_COUNT}',\
    tag:'attack-ddos'"

# Rule 2: Detect HTTP/2 suspicious patterns
SecRule REQUEST_PROTOCOL "@streq HTTP/2.0" \
    "id:1002,\
    phase:1,\
    pass,\
    msg:'HTTP/2 request detected',\
    tag:'protocol-http2'"

# Rule 3: Detect suspicious user-agent patterns
SecRule REQUEST_HEADERS:User-Agent "@rx Chrome/14[0-3]\.0\.0\.0" \
    "id:1003,\
    phase:1,\
    block,\
    msg:'Suspicious user-agent pattern',\
    tag:'attack-ddos'"

# Rule 4: Detect Cloudflare challenge cookie patterns
SecRule REQUEST_COOKIES:__cf_bm "@rx ^[A-Za-z0-9]{23}_[A-Za-z0-9]{19}-\d{10}-" \
    "id:1004,\
    phase:1,\
    pass,\
    msg:'Cloudflare challenge cookie detected',\
    tag:'bot-detection'"

# Rule 5: Detect sequential query parameters
SecRule ARGS "@rx ^[a-z]{6,7}&[a-z]{6,7}$" \
    "id:1005,\
    phase:2,\
    block,\
    msg:'Suspicious query parameter pattern',\
    tag:'attack-ddos'"
```

### Layer 4: Application-Level Protection

#### Node.js/Express.js

```javascript
const express = require('express');
const rateLimit = require('express-rate-limit');
const { createProxyMiddleware } = require('http-proxy-middleware');

const app = express();

// Rate limiting middleware
const apiLimiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100, // limit each IP to 100 requests per windowMs
  message: 'Too many requests from this IP, please try again later.',
  standardHeaders: true,
  legacyHeaders: false,
  skip: (req) => {
    // Skip rate limiting for whitelisted IPs
    const whitelist = ['127.0.0.1', '::1'];
    return whitelist.includes(req.ip);
  },
  handler: (req, res) => {
    res.status(429).json({
      error: 'Rate limit exceeded',
      retryAfter: Math.ceil(req.rateLimit.resetTime / 1000)
    });
  }
});

// HTTP/2 detection middleware
const http2Detection = (req, res, next) => {
  if (req.httpVersion === '2.0') {
    // Log HTTP/2 requests
    console.log(`HTTP/2 request from ${req.ip}: ${req.url}`);
    
    // Check for suspicious patterns
    const suspiciousHeaders = [
      'x-client-session',
      'sec-ms-gec-version',
      'sec-fetch-users',
      'x-request-data'
    ];
    
    const hasSuspiciousHeaders = suspiciousHeaders.some(header => 
      req.headers[header.toLowerCase()]
    );
    
    if (hasSuspiciousHeaders) {
      return res.status(403).json({ error: 'Suspicious request detected' });
    }
  }
  next();
};

// Apply middleware
app.use(http2Detection);
app.use('/api/', apiLimiter);

// IP whitelisting/blacklisting
const ipFilter = (req, res, next) => {
  const blacklist = require('./blacklist.json'); // Load from file
  const clientIP = req.ip || req.connection.remoteAddress;
  
  if (blacklist.includes(clientIP)) {
    return res.status(403).json({ error: 'IP address blocked' });
  }
  
  next();
};

app.use(ipFilter);

// Request validation
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Routes
app.get('/api/data', (req, res) => {
  res.json({ message: 'API response' });
});

app.listen(3000, () => {
  console.log('Server running on port 3000');
});
```

#### Python/Flask

```python
from flask import Flask, request, jsonify
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address
import re

app = Flask(__name__)

# Rate limiting
limiter = Limiter(
    app=app,
    key_func=get_remote_address,
    default_limits=["200 per day", "50 per hour", "20 per minute"]
)

# HTTP/2 detection
@app.before_request
def detect_http2():
    if request.environ.get('SERVER_PROTOCOL') == 'HTTP/2.0':
        # Log HTTP/2 requests
        app.logger.info(f"HTTP/2 request from {request.remote_addr}: {request.path}")
        
        # Check for suspicious headers
        suspicious_headers = [
            'x-client-session',
            'sec-ms-gec-version',
            'sec-fetch-users',
            'x-request-data'
        ]
        
        for header in suspicious_headers:
            if header in request.headers:
                return jsonify({'error': 'Suspicious request detected'}), 403

# IP blacklist
BLACKLIST = ['192.168.1.100', '10.0.0.50']  # Load from database/file

@app.before_request
def check_blacklist():
    if request.remote_addr in BLACKLIST:
        return jsonify({'error': 'IP address blocked'}), 403

# Route with rate limiting
@app.route('/api/data')
@limiter.limit("10 per minute")
def api_data():
    return jsonify({'message': 'API response'})

if __name__ == '__main__':
    app.run(debug=True)
```

---

## Monitoring & Alerting

### Prometheus Metrics

```javascript
const prometheus = require('prom-client');

// Create metrics
const httpRequestsTotal = new prometheus.Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'status', 'protocol']
});

const httpRequestDuration = new prometheus.Histogram({
  name: 'http_request_duration_seconds',
  help: 'Duration of HTTP requests in seconds',
  labelNames: ['method', 'status']
});

const rateLimitHits = new prometheus.Counter({
  name: 'rate_limit_hits_total',
  help: 'Total number of rate limit hits',
  labelNames: ['ip', 'endpoint']
});

// Middleware to collect metrics
app.use((req, res, next) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = (Date.now() - start) / 1000;
    httpRequestsTotal.inc({
      method: req.method,
      status: res.statusCode,
      protocol: req.httpVersion
    });
    httpRequestDuration.observe({
      method: req.method,
      status: res.statusCode
    }, duration);
  });
  
  next();
});
```

### Grafana Dashboard Queries

```promql
# High request rate detection
rate(http_requests_total[1m]) > 100

# Rate limit hits
rate(rate_limit_hits_total[5m]) > 10

# HTTP/2 request percentage
sum(rate(http_requests_total{protocol="2.0"}[5m])) / 
sum(rate(http_requests_total[5m])) > 0.5
```

### Alerting Rules (Alertmanager)

```yaml
groups:
  - name: http_flood_alerts
    rules:
      - alert: HighRequestRate
        expr: rate(http_requests_total[1m]) > 1000
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "High request rate detected"
          description: "Request rate is {{ $value }} req/s"
      
      - alert: RateLimitHits
        expr: rate(rate_limit_hits_total[5m]) > 50
        for: 2m
        labels:
          severity: warning
        annotations:
          summary: "High rate limit hits"
          description: "Rate limit hits: {{ $value }} hits/min"
      
      - alert: HTTP2Attack
        expr: sum(rate(http_requests_total{protocol="2.0"}[5m])) / 
              sum(rate(http_requests_total[5m])) > 0.8
        for: 5m
        labels:
          severity: critical
        annotations:
          summary: "Potential HTTP/2 flood attack"
          description: "HTTP/2 requests: {{ $value }}%"
```

---

## Advanced Detection

### Machine Learning-Based Detection

```python
import numpy as np
from sklearn.ensemble import IsolationForest
from collections import deque

class HTTPFloodDetector:
    def __init__(self):
        self.model = IsolationForest(contamination=0.1, random_state=42)
        self.request_history = deque(maxlen=1000)
        self.is_trained = False
    
    def extract_features(self, request):
        """Extract features from HTTP request"""
        features = [
            len(request.headers),  # Number of headers
            len(request.url),  # URL length
            request.method == 'GET',  # Is GET request
            'user-agent' in request.headers,  # Has user-agent
            'referer' in request.headers,  # Has referer
            request.http_version == '2.0',  # Is HTTP/2
        ]
        return np.array(features)
    
    def add_request(self, request):
        """Add request to history and detect anomalies"""
        features = self.extract_features(request)
        self.request_history.append(features)
        
        if len(self.request_history) >= 100 and not self.is_trained:
            # Train model
            X = np.array(list(self.request_history))
            self.model.fit(X)
            self.is_trained = True
        
        if self.is_trained:
            # Detect anomaly
            prediction = self.model.predict([features])
            if prediction[0] == -1:  # Anomaly detected
                return True
        
        return False

# Usage
detector = HTTPFloodDetector()

def detect_attack(request):
    if detector.add_request(request):
        # Block or challenge request
        return True
    return False
```

### Behavioral Analysis

```python
class BehavioralAnalyzer:
    def __init__(self):
        self.ip_profiles = {}
    
    def analyze_request(self, ip, request):
        """Analyze request behavior"""
        if ip not in self.ip_profiles:
            self.ip_profiles[ip] = {
                'request_count': 0,
                'unique_paths': set(),
                'header_patterns': [],
                'timing_patterns': [],
                'last_request_time': None
            }
        
        profile = self.ip_profiles[ip]
        profile['request_count'] += 1
        profile['unique_paths'].add(request.path)
        
        # Check for suspicious patterns
        if profile['request_count'] > 100 and len(profile['unique_paths']) < 5:
            # High request count but few unique paths
            return True, "High request rate with low path diversity"
        
        if len(profile['header_patterns']) > 10:
            # Check header consistency
            if len(set(profile['header_patterns'])) == 1:
                # All headers identical
                return True, "Identical header patterns"
        
        return False, None
```

---

## Complete Protection Scripts

### Nginx Protection Script

```bash
#!/bin/bash
# nginx-protection-setup.sh

# Create rate limit zones
cat >> /etc/nginx/nginx.conf << 'EOF'
http {
    limit_req_zone $binary_remote_addr zone=api_limit:10m rate=20r/s;
    limit_req_zone $binary_remote_addr zone=general_limit:10m rate=50r/s;
    limit_conn_zone $binary_remote_addr zone=conn_limit:10m;
}
EOF

# Create protection configuration
cat > /etc/nginx/conf.d/protection.conf << 'EOF'
server {
    limit_conn conn_limit 10;
    
    location /api/ {
        limit_req zone=api_limit burst=30 nodelay;
        limit_req_status 429;
    }
    
    location / {
        limit_req zone=general_limit burst=50 nodelay;
        limit_req_status 429;
    }
    
    error_page 429 @ratelimit;
    location @ratelimit {
        return 429 '{"error": "Rate limit exceeded"}';
        add_header Content-Type application/json;
    }
}
EOF

# Test and reload
nginx -t && systemctl reload nginx
```

### IP Blacklist Management Script

```python
#!/usr/bin/env python3
# ip-blacklist-manager.py

import json
import redis
from datetime import datetime, timedelta

class IPBlacklistManager:
    def __init__(self, redis_host='localhost', redis_port=6379):
        self.redis_client = redis.Redis(host=redis_host, port=redis_port, db=0)
        self.blacklist_key = 'ip_blacklist'
        self.attack_log_key = 'attack_log'
    
    def add_ip(self, ip, reason, duration_hours=24):
        """Add IP to blacklist"""
        expiry = datetime.now() + timedelta(hours=duration_hours)
        ip_data = {
            'ip': ip,
            'reason': reason,
            'added_at': datetime.now().isoformat(),
            'expires_at': expiry.isoformat()
        }
        
        self.redis_client.hset(
            self.blacklist_key,
            ip,
            json.dumps(ip_data)
        )
        
        # Set expiry
        self.redis_client.expire(
            self.blacklist_key,
            int(duration_hours * 3600)
        )
        
        # Log attack
        self.redis_client.lpush(
            self.attack_log_key,
            json.dumps({
                'ip': ip,
                'reason': reason,
                'timestamp': datetime.now().isoformat()
            })
        )
    
    def is_blacklisted(self, ip):
        """Check if IP is blacklisted"""
        return self.redis_client.hexists(self.blacklist_key, ip)
    
    def remove_ip(self, ip):
        """Remove IP from blacklist"""
        self.redis_client.hdel(self.blacklist_key, ip)
    
    def get_blacklist(self):
        """Get all blacklisted IPs"""
        return self.redis_client.hgetall(self.blacklist_key)

# Usage
manager = IPBlacklistManager()

# Add attacking IP
manager.add_ip('192.168.1.100', 'High request rate', duration_hours=24)

# Check if IP is blacklisted
if manager.is_blacklisted('192.168.1.100'):
    print("IP is blacklisted")
```

---

## Summary

This comprehensive protection guide provides multiple layers of defense against HTTP/2 and HTTP/1.1 flood attacks:

1. **CDN/DDoS Protection** - First line of defense at the edge
2. **Web Server Rate Limiting** - Nginx/Apache level protection
3. **WAF Rules** - Application-level filtering
4. **Application Protection** - Code-level rate limiting and validation
5. **Monitoring & Alerting** - Real-time detection and notification
6. **Advanced Detection** - ML-based and behavioral analysis

**Best Practices:**
- Implement multiple layers of protection
- Monitor request patterns continuously
- Update protection rules regularly
- Test defenses periodically
- Have an incident response plan ready

**Remember:** No single protection method is 100% effective. Use a combination of these strategies for maximum protection.

